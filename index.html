<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ventricular Depolarization: The QRS Loop</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8f9fa;
            color: #1f2937;
            overflow: hidden;
            margin: 0;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .glass-panel {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.6);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            border-radius: 16px;
        }

        .lead-btn {
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }
        .lead-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .lead-btn.active {
            background-color: #dc2626; /* Red-600 */
            color: white;
            border-color: #dc2626;
        }
        /* Indicator for active lead angle */
        .lead-btn.active::after {
            content: '';
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            width: 6px;
            height: 6px;
            background: white;
            border-radius: 50%;
        }

        #ecg-canvas {
            width: 100%;
            height: 100%;
        }

        /* Range Slider Styling */
        input[type=range] {
            -webkit-appearance: none; 
            background: transparent; 
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #dc2626;
            cursor: pointer;
            margin-top: -6px; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #e2e8f0;
            border-radius: 2px;
        }
    </style>
</head>
<body>

    <!-- 3D Container -->
    <div id="canvas-container"></div>

    <!-- UI Layout -->
    <div class="relative z-10 flex flex-col h-screen pointer-events-none">
        
        <!-- Header -->
        <div class="flex justify-between items-start p-6 w-full pointer-events-auto">
            <div class="glass-panel px-6 py-4 flex flex-col gap-1">
                <h1 class="text-xl font-bold text-gray-800 flex items-center gap-2">
                    <span class="w-3 h-3 rounded-full bg-red-600"></span>
                    Ventricular Depolarization
                </h1>
                <p class="text-xs text-gray-500 font-medium tracking-wide uppercase">QRS Complex Simulation</p>
            </div>
            
            <div class="glass-panel px-6 py-3 flex items-center gap-6">
                <!-- Speed Control -->
                <div class="flex flex-col gap-1">
                    <div class="flex justify-between">
                        <label for="speed-slider" class="text-xs font-bold text-gray-500 uppercase tracking-wider">Rapidity</label>
                        <span id="speed-val" class="text-xs font-mono text-red-600">0.5x</span>
                    </div>
                    <input type="range" id="speed-slider" min="0.1" max="3.0" step="0.1" value="0.5" class="w-32">
                </div>

                <div class="h-8 w-px bg-gray-200"></div>

                <!-- Axis Control -->
                <div class="flex flex-col gap-1">
                    <div class="flex justify-between">
                        <label for="axis-slider" class="text-xs font-bold text-gray-500 uppercase tracking-wider">Heart Axis</label>
                        <span id="axis-val" class="text-xs font-mono text-blue-600">60°</span>
                    </div>
                    <input type="range" id="axis-slider" min="-90" max="180" step="5" value="60" class="w-32">
                </div>

                <div class="h-8 w-px bg-gray-200"></div>

                <button id="play-pause-btn" class="w-8 h-8 flex items-center justify-center rounded-full bg-gray-100 hover:bg-red-50 text-gray-700 hover:text-red-600 transition">
                    <!-- Pause Icon -->
                    <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24" id="icon-pause">
                        <path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/>
                    </svg>
                </button>
            </div>
        </div>

        <!-- Main Content Area -->
        <div class="flex flex-1 overflow-hidden px-6 pb-6 gap-6">
            
            <!-- Left Sidebar: Leads -->
            <div class="glass-panel w-64 flex flex-col overflow-hidden pointer-events-auto shadow-lg">
                <div class="p-4 border-b border-gray-100 bg-gray-50/80">
                    <h2 class="text-xs font-bold text-gray-500 uppercase tracking-wider">Frontal Plane Leads</h2>
                </div>
                <div class="overflow-y-auto flex-1 p-3 space-y-2">
                    
                    <div class="text-[10px] font-bold text-gray-400 px-1 mt-1 mb-1 uppercase">Bipolar (Einthoven)</div>
                    <button class="lead-btn active w-full text-left px-4 py-3 rounded-xl text-sm font-semibold border border-transparent bg-white shadow-sm" onclick="setLead('I')">
                        Lead I <span class="block text-[10px] opacity-70 font-normal">0° (Lateral)</span>
                    </button>
                    <button class="lead-btn w-full text-left px-4 py-3 rounded-xl text-sm font-semibold border border-transparent bg-white shadow-sm" onclick="setLead('II')">
                        Lead II <span class="block text-[10px] opacity-70 font-normal">+60° (Inferior)</span>
                    </button>
                    <button class="lead-btn w-full text-left px-4 py-3 rounded-xl text-sm font-semibold border border-transparent bg-white shadow-sm" onclick="setLead('III')">
                        Lead III <span class="block text-[10px] opacity-70 font-normal">+120° (Inferior)</span>
                    </button>
                    
                    <div class="text-[10px] font-bold text-gray-400 px-1 mt-3 mb-1 uppercase">Augmented Unipolar</div>
                    <button class="lead-btn w-full text-left px-4 py-3 rounded-xl text-sm font-semibold border border-transparent bg-white shadow-sm" onclick="setLead('aVR')">
                        aVR <span class="block text-[10px] opacity-70 font-normal">-150° (Right)</span>
                    </button>
                    <button class="lead-btn w-full text-left px-4 py-3 rounded-xl text-sm font-semibold border border-transparent bg-white shadow-sm" onclick="setLead('aVL')">
                        aVL <span class="block text-[10px] opacity-70 font-normal">-30° (Left)</span>
                    </button>
                    <button class="lead-btn w-full text-left px-4 py-3 rounded-xl text-sm font-semibold border border-transparent bg-white shadow-sm" onclick="setLead('aVF')">
                        aVF <span class="block text-[10px] opacity-70 font-normal">+90° (Foot)</span>
                    </button>
                </div>
            </div>

            <!-- Middle: Invisible interactive area -->
            <div class="flex-1 pointer-events-none flex flex-col justify-end pb-10 items-center">
                <div class="glass-panel px-6 py-4 text-center pointer-events-none animate-pulse">
                    <p class="text-sm font-semibold text-gray-700">
                        Current Phase: <span id="phase-indicator" class="text-red-600 font-bold">Septal</span>
                    </p>
                </div>
            </div>

            <!-- Right: Real-time Graph -->
            <div class="glass-panel w-96 flex flex-col pointer-events-auto relative overflow-hidden bg-white shadow-lg">
                <!-- ECG Grid Background -->
                <div class="absolute inset-0 opacity-20" 
                     style="background-image: linear-gradient(#ef4444 0.5px, transparent 0.5px), linear-gradient(90deg, #ef4444 0.5px, transparent 0.5px); background-size: 20px 20px;">
                </div>
                <div class="absolute inset-0 opacity-20" 
                     style="background-image: linear-gradient(#ef4444 0.2px, transparent 0.2px), linear-gradient(90deg, #ef4444 0.2px, transparent 0.2px); background-size: 4px 4px;">
                </div>

                <div class="p-5 border-b border-gray-100 relative z-10 bg-white/90 backdrop-blur flex justify-between items-end">
                    <div>
                        <h2 id="lead-title" class="text-2xl font-bold text-gray-800">Lead I</h2>
                        <p id="lead-desc" class="text-xs text-gray-500 font-medium mt-1">Projecting on 0° Axis</p>
                    </div>
                    <div class="text-right">
                        <span id="current-voltage" class="font-mono text-xl text-red-600 font-bold tracking-tight">0.00</span>
                        <span class="text-xs text-gray-400 font-bold block">mV</span>
                    </div>
                </div>
                <div class="flex-1 relative">
                    <canvas id="ecg-canvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            speed: 0.5, // default simulation speed multiplier
            loopDuration: 100, // abstract time units for one QRS loop
            axisAngle: 60 // Degrees
        };

        let loopTime = 0; // 0 to 100
        let isPaused = false;
        let activeLead = 'I';
        let currentPhase = "";

        // --- PHYSICS: VENTRICULAR DEPOLARIZATION VECTOR ---
        // Calculating the vector P(t) during the QRS complex.
        // Coordinate System (Medical Frontal Plane):
        // X+ = 0° (Left Arm)
        // Y+ = 90° (Foot/Inferior)
        // Z+ = Anterior (used for 3D depth, though not projected in limb leads)
        
        function getQRSVector(progress) {
            // progress is 0.0 to 1.0
            const p = new THREE.Vector3(0, 0, 0);
            let phase = "";

            // 1. SEPTAL DEPOLARIZATION (Q wave part)
            // Time: 0.0 - 0.15
            // Normal Direction: Left to Right (~160 deg)
            // We shift this slightly based on axis, but usually Septal is anatomically fixed relatively
            if (progress < 0.15) {
                phase = "Septal Activation";
                const t = progress / 0.15; // 0-1
                const magnitude = 0.3 * Math.sin(t * Math.PI); 
                
                // Septal vector is roughly opposite to the main axis but usually fixed rightward
                // Let's make it static relative to anatomy for simplicity
                const angle = 160 * (Math.PI / 180);
                p.x = magnitude * Math.cos(angle);
                p.y = magnitude * Math.sin(angle);
                p.z = magnitude * 0.5; // Anterior
            }
            
            // 2. MAIN VENTRICULAR ACTIVATION (R wave part)
            // Time: 0.15 - 0.70
            // This is the part that heavily depends on the ELECTRICAL AXIS
            else if (progress < 0.70) {
                phase = "Main Ventricular";
                const t = (progress - 0.15) / 0.55; // 0-1
                const magnitude = 1.8 * Math.sin(t * Math.PI); // Large magnitude
                
                // Use the User Defined Axis Angle
                const angle = CONFIG.axisAngle * (Math.PI / 180);
                
                p.x = magnitude * Math.cos(angle);
                p.y = magnitude * Math.sin(angle);
                p.z = -magnitude * 0.2; // Slightly posterior
            }

            // 3. BASAL ACTIVATION (S wave part)
            // Time: 0.70 - 1.0
            // Usually opposite to apex, towards base (~ -100 deg)
            // If axis shifts, base shifts too? Usually yes.
            else {
                phase = "Basal Activation";
                const t = (progress - 0.70) / 0.30; // 0-1
                const magnitude = 0.5 * Math.sin(t * Math.PI); 
                
                // Base is roughly Axis + 180 +/- deviation
                // Let's approximate Base as (Axis - 160) degrees to keep loop shape
                const angle = (CONFIG.axisAngle - 160) * (Math.PI / 180);
                
                p.x = magnitude * Math.cos(angle);
                p.y = magnitude * Math.sin(angle);
                p.z = -magnitude * 0.4; // Posterior
            }

            return { vec: p, phase: phase };
        }

        // --- LEAD DEFINITIONS (Frontal Plane) ---
        const LEADS = {
            'I':   { angle: 0,    name: "Lead I", desc: "Left Lateral View (0°)" },
            'II':  { angle: 60,   name: "Lead II", desc: "Inferior View (+60°)" },
            'III': { angle: 120,  name: "Lead III", desc: "Right Inferior View (+120°)" },
            'aVR': { angle: -150, name: "aVR", desc: "Right Atrium View (-150°)" },
            'aVL': { angle: -30,  name: "aVL", desc: "High Lateral View (-30°)" },
            'aVF': { angle: 90,   name: "aVF", desc: "Inferior Foot View (+90°)" }
        };

        // Convert angles to Vectors
        Object.keys(LEADS).forEach(key => {
            const rad = LEADS[key].angle * (Math.PI / 180);
            LEADS[key].vec = new THREE.Vector3(Math.cos(rad), Math.sin(rad), 0);
        });

        // --- 3D SCENE SETUP ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0xf8f9fa, 0.02);

        const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 8); 

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 4;
        controls.maxDistance = 12;
        controls.enablePan = false;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
        dirLight.position.set(5, 5, 10);
        scene.add(dirLight);

        // --- OBJECTS ---

        // 1. Einthoven's Triangle (Visual Aid)
        const triangleGroup = new THREE.Group();
        const circleGeo = new THREE.RingGeometry(3.0, 3.02, 64);
        const circleMat = new THREE.MeshBasicMaterial({ color: 0xcbd5e1, side: THREE.DoubleSide, transparent: true, opacity: 0.3 });
        const circle = new THREE.Mesh(circleGeo, circleMat);
        scene.add(circle);

        const leadsVisual = new THREE.Group();
        Object.keys(LEADS).forEach(key => {
            const vec = LEADS[key].vec;
            const x = vec.x * 3;
            const y = -vec.y * 3; // Invert Y for 3D visual
            const points = [new THREE.Vector3(0, 0, 0), new THREE.Vector3(x, y, 0)];
            const geo = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geo, new THREE.LineBasicMaterial({ color: 0x94a3b8, transparent: true, opacity: 0.3 }));
            leadsVisual.add(line);
        });
        scene.add(leadsVisual);

        // 2. The Heart (Stylized)
        const heartGeo = new THREE.SphereGeometry(0.4, 32, 32);
        // Elongate slightly to show axis better
        heartGeo.scale(0.8, 1.2, 0.8); 
        const heartMat = new THREE.MeshPhongMaterial({ color: 0xfecaca, transparent: true, opacity: 0.9, shininess: 50 });
        const heart = new THREE.Mesh(heartGeo, heartMat);
        // We will rotate this heart mesh to match the axis
        scene.add(heart);

        // 3. The Cardiac Vector (Arrow)
        const arrowGroup = new THREE.Group();
        scene.add(arrowGroup);
        const shaftGeo = new THREE.CylinderGeometry(0.06, 0.06, 1, 16);
        shaftGeo.translate(0, 0.5, 0);
        shaftGeo.rotateZ(-Math.PI/2); 
        const shaft = new THREE.Mesh(shaftGeo, new THREE.MeshPhongMaterial({ color: 0xdc2626 }));
        const headGeo = new THREE.ConeGeometry(0.18, 0.4, 16);
        headGeo.translate(0, 1, 0);
        headGeo.rotateZ(-Math.PI/2);
        const head = new THREE.Mesh(headGeo, new THREE.MeshPhongMaterial({ color: 0xdc2626 }));
        arrowGroup.add(shaft);
        arrowGroup.add(head);

        // 4. Active Lead Axis (Blue Line)
        const axisLineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-10,0,0), new THREE.Vector3(10,0,0)]);
        const axisLine = new THREE.Line(axisLineGeo, new THREE.LineBasicMaterial({ color: 0x3b82f6, linewidth: 2 }));
        scene.add(axisLine);

        // 5. Projection Line (Dashed)
        const projLineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,0)]);
        const projLine = new THREE.Line(projLineGeo, new THREE.LineDashedMaterial({ color: 0x3b82f6, dashSize: 0.1, gapSize: 0.1 }));
        projLine.computeLineDistances();
        scene.add(projLine);

        // --- 2D GRAPH ---
        const canvas = document.getElementById('ecg-canvas');
        const ctx = canvas.getContext('2d');
        let history = [];
        const maxHistory = 300;

        function resizeCanvas() {
            canvas.width = canvas.clientWidth * window.devicePixelRatio;
            canvas.height = canvas.clientHeight * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // --- CONTROLS BINDING ---
        const speedSlider = document.getElementById('speed-slider');
        const speedVal = document.getElementById('speed-val');
        speedSlider.addEventListener('input', (e) => {
            CONFIG.speed = parseFloat(e.target.value);
            speedVal.innerText = CONFIG.speed + "x";
        });

        const axisSlider = document.getElementById('axis-slider');
        const axisVal = document.getElementById('axis-val');
        axisSlider.addEventListener('input', (e) => {
            CONFIG.axisAngle = parseInt(e.target.value);
            axisVal.innerText = (CONFIG.axisAngle > 0 ? "+" : "") + CONFIG.axisAngle + "°";
            
            // Update Heart Model Rotation immediately
            // Normal Heart (60 deg) means the tip points to bottom-left.
            // In 3D visual: Y is Up. Medical 60deg is -60 from X axis in standard math?
            // Medical 0 is X+. Medical 90 is Y-. 
            // So angle theta in Medical -> -theta in 3D Visual Z-Rotation.
            // But our heart geometry is vertical initially (Y-aligned). 
            // Let's just map it: -60 deg rotation puts it in normal axis.
            // So rotationZ = -(axis - 90) * rad? No, simpler.
            // Visual Angle = -Medical Angle.
            heart.rotation.z = -CONFIG.axisAngle * (Math.PI / 180) + (90 * Math.PI/180); 
            // Adding 90 offset because sphere geometry y-axis is default up
        });
        // Trigger initial rotation
        heart.rotation.z = -CONFIG.axisAngle * (Math.PI / 180) + (90 * Math.PI/180);

        const playBtn = document.getElementById('play-pause-btn');
        playBtn.addEventListener('click', () => {
            isPaused = !isPaused;
            playBtn.innerHTML = isPaused 
                ? '<svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>'
                : '<svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24"><path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/></svg>';
        });

        window.setLead = function(name) {
            activeLead = name;
            document.querySelectorAll('.lead-btn').forEach(btn => {
                btn.classList.remove('active');
                if(btn.innerText.includes(name)) btn.classList.add('active');
            });
            document.getElementById('lead-title').innerText = LEADS[name].name;
            document.getElementById('lead-desc').innerText = LEADS[name].desc;
            history = []; // Clear graph
        }

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            if (!isPaused) {
                loopTime += CONFIG.speed;
                if (loopTime > CONFIG.loopDuration) {
                    loopTime = 0;
                }
            }

            const progress = loopTime / CONFIG.loopDuration;

            // 1. PHYSICS
            const data = getQRSVector(progress);
            const p_med = data.vec; // Medical coords (x,y,z)
            document.getElementById('phase-indicator').innerText = data.phase;

            // 2. VISUALS (Map Medical -> 3D)
            const p_vis = new THREE.Vector3(p_med.x, -p_med.y, p_med.z);
            const magnitude = p_vis.length();

            if (magnitude > 0.01) {
                arrowGroup.visible = true;
                arrowGroup.lookAt(p_vis);
                arrowGroup.scale.set(1,1,1); 
                arrowGroup.quaternion.setFromUnitVectors(new THREE.Vector3(1,0,0), p_vis.clone().normalize());
                arrowGroup.scale.set(magnitude, magnitude, magnitude); 
            } else {
                arrowGroup.visible = false;
            }

            // 3. LEAD PROJECTION
            const leadMed = LEADS[activeLead].vec;
            const leadVis = new THREE.Vector3(leadMed.x, -leadMed.y, 0);
            
            axisLine.quaternion.setFromUnitVectors(new THREE.Vector3(1,0,0), leadVis);

            const voltage = p_med.dot(leadMed);
            document.getElementById('current-voltage').innerText = voltage.toFixed(2);

            const scalarProj = p_vis.dot(leadVis.clone().normalize());
            const projPoint = leadVis.clone().normalize().multiplyScalar(scalarProj);
            
            projLine.geometry.setFromPoints([p_vis, projPoint]);
            projLine.computeLineDistances();
            projLine.geometry.attributes.position.needsUpdate = true;

            // 4. GRAPH
            if (!isPaused) {
                history.push(voltage);
                if (history.length > maxHistory) history.shift();
            }
            renderGraph();

            controls.update();
            renderer.render(scene, camera);
        }

        function renderGraph() {
            const w = canvas.clientWidth;
            const h = canvas.clientHeight;
            ctx.clearRect(0, 0, w, h);

            // Grid
            ctx.strokeStyle = '#fee2e2';
            ctx.lineWidth = 1;
            ctx.beginPath();
            const gw = w/20;
            for(let i=0; i<w; i+=gw) { ctx.moveTo(i,0); ctx.lineTo(i,h); }
            for(let i=0; i<h; i+=gw) { ctx.moveTo(0,i); ctx.lineTo(w,i); }
            ctx.stroke();

            // Baseline
            const mid = h/2;
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(0, mid);
            ctx.lineTo(w, mid);
            ctx.stroke();

            // Plot
            ctx.strokeStyle = '#1f2937';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            
            const dx = w / maxHistory;
            const scaleY = (h/2) * 0.8; 

            for(let i=0; i<history.length; i++) {
                const x = i * dx;
                const y = mid - (history[i] * scaleY / 2);
                if(i===0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            if(history.length > 0) {
                const lastX = (history.length-1) * dx;
                const lastY = mid - (history[history.length-1] * scaleY / 2);
                ctx.fillStyle = '#dc2626';
                ctx.beginPath();
                ctx.arc(lastX, lastY, 5, 0, Math.PI*2);
                ctx.fill();
            }
        }

        animate();

    </script>
</body>
</html>
